/*
Дан список интов, повторяющихся элементов в списке нет. Нужно преобразовать это множество в строку,
 сворачивая соседние по числовому ряду числа в диапазоны.
Примеры:

    [1,4,5,2,3,9,8,11,0] => "0-5,8-9,11"

*/

log64;

// 2^1 2^2 2^3 2^4  2^5  2^6
//  2   4   8   16   32   64

// 1 2 3 4 5 6 7 8

function transormArray(arr) {
  arr.sort((a, b) => a - b); // n*logn

  let l = 0;
  let r = 0;
  let res = [];

  while (r < arr.length) {
    // n
    l = r;
    while (r + 1 < arr.length && arr[r + 1] === arr[r] + 1) {
      r += 1;
    }

    if (l === r) {
      res.push(arr[l]);
    } else {
      res.push(arr[l] + '-' + arr[r]);
    }

    r += 1;
  }

  return res.join(','); // n
}

//  1 3 4 5
//    ^
//        ^

// 0 6 8 3 5 9 2 1
// 0 1 2 3 5 6 8 9

/*
Есть строка S состоящая из строчных букв.
Требуется разделить строку на максимальное число частей так,
 чтобы каждая буква появлялась не более, чем в одной части.
Пример:
Если S = abcaeeeffdgfdd , то в ответе должен быть список строк abca , eee , ffdgfdd .
Видно, что ответ является корректным, также несложно проверить,
 что на большее число частей раздеть строку не получится.
Кроме того решение abcaeee , ffdgfdd не является правильным, так как S можно разбить на большее число частей.
*/

function solution(s) {
  const dict = {};

  for (let i = 0; i < array.length; i++) {
    const cur = array[i];

    dict[cur] = dict[cur] || dict[cur] + 1;
  }

  let end = 0;
  let start = 0;
}
